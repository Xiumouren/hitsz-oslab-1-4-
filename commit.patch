diff --git a/Makefile b/Makefile
index b971308..498ba9e 100644
--- a/Makefile
+++ b/Makefile
@@ -157,6 +157,9 @@ UPROGS=\
 	$U/_grind\
 	$U/_wc\
 	$U/_zombie\
+  $U/_sleep\
+  $U/_pingpong\
+  $U/_find\
 
 
 ifeq ($(LAB),syscall)
@@ -242,15 +245,8 @@ qemu-gdb: $K/kernel .gdbinit fs.img
 	@echo "*** Now run 'gdb' in another window." 1>&2
 	$(QEMU) $(QEMUOPTS) -S $(QEMUGDB)
 
-GDBARGS = 
-GDBARGS += -ex 'set architecture riscv:rv64'
-GDBARGS += -ex 'target remote 127.0.0.1:$(GDBPORT)'
-GDBARGS += -ex 'symbol-file kernel/kernel'
-GDBARGS += -ex 'set riscv use-compressed-breakpoints yes'
-
-
 gdb: 
-	$(GDB) $(GDBARGS)
+	$(GDB)
 
 ##
 ##  FOR testing lab grading script
diff --git a/commands.gdb b/commands.gdb
new file mode 100644
index 0000000..b5be2e5
--- /dev/null
+++ b/commands.gdb
@@ -0,0 +1,97 @@
+si
+si
+si
+si
+si
+b *0x0000000080000016
+c
+si
+u 58
+si
+n
+n
+n
+n
+n
+n
+b main.c:42
+c
+s
+n
+n
+n
+n
+n
+n
+n
+n
+si
+si
+si
+si
+si 10
+si 10
+si 5
+si 3
+si
+n
+n
+n
+n
+n
+s
+n
+n
+p cpus[$tp]->proc->name
+n
+n
+n
+n
+n
+n
+n
+n
+n
+n
+n
+n
+si
+si
+si
+si
+si
+si
+si
+si
+si
+si
+si
+si
+si
+si 10
+si 10
+si 10
+si 5
+si
+si
+si
+si 5
+si 5
+si 5
+si 5
+si 5
+si 8
+si
+si
+si 5
+si
+si
+si
+u 45
+n
+n
+n
+n
+p cpus[$tp]->proc->name
+da
+q
\ No newline at end of file
diff --git a/commit.patch b/commit.patch
new file mode 100644
index 0000000..3f9a949
--- /dev/null
+++ b/commit.patch
@@ -0,0 +1,370 @@
+diff --git a/Makefile b/Makefile
+index b971308..498ba9e 100644
+--- a/Makefile
++++ b/Makefile
+@@ -157,6 +157,9 @@ UPROGS=\
+ 	$U/_grind\
+ 	$U/_wc\
+ 	$U/_zombie\
++  $U/_sleep\
++  $U/_pingpong\
++  $U/_find\
+ 
+ 
+ ifeq ($(LAB),syscall)
+@@ -242,15 +245,8 @@ qemu-gdb: $K/kernel .gdbinit fs.img
+ 	@echo "*** Now run 'gdb' in another window." 1>&2
+ 	$(QEMU) $(QEMUOPTS) -S $(QEMUGDB)
+ 
+-GDBARGS = 
+-GDBARGS += -ex 'set architecture riscv:rv64'
+-GDBARGS += -ex 'target remote 127.0.0.1:$(GDBPORT)'
+-GDBARGS += -ex 'symbol-file kernel/kernel'
+-GDBARGS += -ex 'set riscv use-compressed-breakpoints yes'
+-
+-
+ gdb: 
+-	$(GDB) $(GDBARGS)
++	$(GDB)
+ 
+ ##
+ ##  FOR testing lab grading script
+diff --git a/commands.gdb b/commands.gdb
+new file mode 100644
+index 0000000..890b4ed
+--- /dev/null
++++ b/commands.gdb
+@@ -0,0 +1,130 @@
++si
++si
++si
++si
++si
++b *0x0000000080000016
++c
++si
++u 58
++si
++n
++n
++n
++n
++n
++n
++n
++n
++n
++n
++n
++n
++n
++n
++n
++n
++n
++s
++n
++n
++n
++n
++n
++n
++n
++fin
++b main.c:42
++c
++s
++n
++n
++n
++n
++n
++n
++n
++n
++si
++si
++si
++si
++exec
++exec
++exec
++si 10
++si 8
++si 5
++si 4
++si
++i r ra
++si
++n
++n
++n
++n
++n
++s
++n
++ p cpus[$tp]->proc->name
++u 112
++si
++si
++si
++si
++si
++si
++si
++si
++si
++si
++si
++si
++si
++si 10
++si 10
++si 10
++si 3
++si
++si
++i r sepc
++si
++si
++si
++si
++si
++si
++si
++si
++si
++si
++si
++si
++si
++i r scause
++si 10
++si 10
++si 10
++si
++si
++si
++n
++n
++n
++n
++n
++n
++n
++n
++n
++i r scause
++n
++n
++n
++n
++n
++s
++n
++ p cpus[$tp]->proc->name
++da
++q
+\ No newline at end of file
+diff --git a/user/find.c b/user/find.c
+new file mode 100644
+index 0000000..5b5573c
+--- /dev/null
++++ b/user/find.c
+@@ -0,0 +1,100 @@
++#include "kernel/types.h"
++#include "kernel/stat.h"
++#include "user/user.h"
++#include "kernel/fs.h"
++#include "kernel/fcntl.h"
++
++/**
++ * 从路径中提取文件名部分
++ */
++char*
++fmt_name(char *path)
++{
++    static char buf[DIRSIZ+1];
++    char *p;
++    
++    // 从字符串末尾向前查找最后一个'/'
++    for(p = path + strlen(path); p >= path && *p != '/'; p--)
++        ;
++    p++;
++    
++    // 如果文件名长度超过DIRSIZ，直接返回指针
++    if(strlen(p) >= DIRSIZ)
++        return p;
++    
++    // 复制文件名到缓冲区
++    memmove(buf, p, strlen(p));
++    buf[strlen(p)] = 0;
++    return buf;
++}
++
++/**
++ * 在指定路径中递归查找文件或目录
++ */
++void
++find(char *path, char *target_name)
++{
++    char buf[512], *p;
++    int fd;
++    struct dirent de;
++    struct stat st;
++    
++    if((fd = open(path, O_RDONLY)) < 0){
++        fprintf(2, "find: cannot open %s\n", path);
++        return;
++    }
++    
++    if(fstat(fd, &st) < 0){
++        fprintf(2, "find: cannot stat %s\n", path);
++        close(fd);
++        return;
++    }
++    
++    // 关键修改：无论是文件还是目录，都先检查名称是否匹配
++    if(strcmp(fmt_name(path), target_name) == 0){
++        printf("%s\n", path);
++    }
++    
++    // 如果是目录，进行递归查找
++    if(st.type == T_DIR){
++        if(strlen(path) + 1 + DIRSIZ + 1 > sizeof buf){
++            printf("find: path too long\n");
++            close(fd);
++            return;
++        }
++        
++        strcpy(buf, path);
++        p = buf + strlen(buf);
++        *p++ = '/';
++        
++        while(read(fd, &de, sizeof(de)) == sizeof(de)){
++            // 跳过无效目录项
++            if(de.inum == 0)
++                continue;
++            
++            // 跳过特殊目录，但要确保这些目录本身能被查找
++            if(strcmp(de.name, ".") == 0 || strcmp(de.name, "..") == 0)
++                continue;
++            
++            memmove(p, de.name, DIRSIZ);
++            p[DIRSIZ] = 0;
++            
++            find(buf, target_name);
++        }
++    }
++    
++    close(fd);
++}
++
++int
++main(int argc, char *argv[])
++{
++    if(argc != 3){
++        fprintf(2, "Usage: find <path> <filename>\n");
++        fprintf(2, "Example: find . b\n");
++        exit(1);
++    }
++    
++    find(argv[1], argv[2]);
++    exit(0);
++}
+\ No newline at end of file
+diff --git a/user/pingpong.c b/user/pingpong.c
+new file mode 100644
+index 0000000..27daa92
+--- /dev/null
++++ b/user/pingpong.c
+@@ -0,0 +1,53 @@
++#include "kernel/types.h"
++#include "user/user.h"
++
++#define READ 0
++#define WRITE 1
++
++int main(int argc, char *argv[]) {
++    int f2c_pipe[2];  
++    int c2f_pipe[2];  
++    char buffer[1];   
++    int father_pid = getpid(); 
++    int pid;             
++
++    if (pipe(f2c_pipe) < 0 || pipe(c2f_pipe) < 0) {
++        fprintf(2, "pipe creation failed\n");
++        exit(1);
++    }
++
++    pid = fork();
++    if (pid < 0) {
++        fprintf(2, "fork failed\n");
++        exit(1);
++    }
++
++    if (pid == 0) {  // 子进程
++        close(f2c_pipe[WRITE]);  
++        close(c2f_pipe[READ]);   
++
++        read(f2c_pipe[READ], buffer, sizeof(buffer));
++        printf("%d: received ping from pid %d\n", getpid(), father_pid);
++
++        write(c2f_pipe[WRITE], buffer, sizeof(buffer));
++
++        close(f2c_pipe[READ]);
++        close(c2f_pipe[WRITE]);
++        exit(0);
++
++    } else {  // 父进程
++        close(f2c_pipe[READ]);   
++        close(c2f_pipe[WRITE]);  
++
++        buffer[0] = 'X';  
++        write(f2c_pipe[WRITE], buffer, sizeof(buffer));
++        close(f2c_pipe[WRITE]);  
++
++        read(c2f_pipe[READ], buffer, sizeof(buffer));
++        printf("%d: received pong from pid %d\n", getpid(), pid);
++        close(c2f_pipe[READ]);
++        
++        wait(0); 
++        exit(0);
++    }
++}
+\ No newline at end of file
+diff --git a/user/sleep.c b/user/sleep.c
+new file mode 100644
+index 0000000..1353a3b
+--- /dev/null
++++ b/user/sleep.c
+@@ -0,0 +1,15 @@
++#include "kernel/types.h"
++#include "user/user.h" 
++
++int main(int argc, char *argv[]) {
++    if (argc != 2) {
++        
++        printf("Sleep needs one argument!\n");
++        exit(-1);
++    }
++
++    int ticks = atoi(argv[1]); // 将字符串参数转换为整数
++    sleep(ticks); // 调用 sleep 系统调用
++    printf("(nothing happens for a little while)\n");
++    exit(0);
++}
+diff --git a/user/testpp.c b/user/testpp.c
+new file mode 100644
+index 0000000..4fac12a
+--- /dev/null
++++ b/user/testpp.c
+@@ -0,0 +1 @@
++HEllo
+diff --git a/xv6-oslab24-hitsz b/xv6-oslab24-hitsz
+new file mode 160000
+index 0000000..f107bad
+--- /dev/null
++++ b/xv6-oslab24-hitsz
+@@ -0,0 +1 @@
++Subproject commit f107bad921cb2528e1dfb8d69653f8d9fe47c42c
diff --git a/user/find.c b/user/find.c
new file mode 100644
index 0000000..5b5573c
--- /dev/null
+++ b/user/find.c
@@ -0,0 +1,100 @@
+#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "user/user.h"
+#include "kernel/fs.h"
+#include "kernel/fcntl.h"
+
+/**
+ * 从路径中提取文件名部分
+ */
+char*
+fmt_name(char *path)
+{
+    static char buf[DIRSIZ+1];
+    char *p;
+    
+    // 从字符串末尾向前查找最后一个'/'
+    for(p = path + strlen(path); p >= path && *p != '/'; p--)
+        ;
+    p++;
+    
+    // 如果文件名长度超过DIRSIZ，直接返回指针
+    if(strlen(p) >= DIRSIZ)
+        return p;
+    
+    // 复制文件名到缓冲区
+    memmove(buf, p, strlen(p));
+    buf[strlen(p)] = 0;
+    return buf;
+}
+
+/**
+ * 在指定路径中递归查找文件或目录
+ */
+void
+find(char *path, char *target_name)
+{
+    char buf[512], *p;
+    int fd;
+    struct dirent de;
+    struct stat st;
+    
+    if((fd = open(path, O_RDONLY)) < 0){
+        fprintf(2, "find: cannot open %s\n", path);
+        return;
+    }
+    
+    if(fstat(fd, &st) < 0){
+        fprintf(2, "find: cannot stat %s\n", path);
+        close(fd);
+        return;
+    }
+    
+    // 关键修改：无论是文件还是目录，都先检查名称是否匹配
+    if(strcmp(fmt_name(path), target_name) == 0){
+        printf("%s\n", path);
+    }
+    
+    // 如果是目录，进行递归查找
+    if(st.type == T_DIR){
+        if(strlen(path) + 1 + DIRSIZ + 1 > sizeof buf){
+            printf("find: path too long\n");
+            close(fd);
+            return;
+        }
+        
+        strcpy(buf, path);
+        p = buf + strlen(buf);
+        *p++ = '/';
+        
+        while(read(fd, &de, sizeof(de)) == sizeof(de)){
+            // 跳过无效目录项
+            if(de.inum == 0)
+                continue;
+            
+            // 跳过特殊目录，但要确保这些目录本身能被查找
+            if(strcmp(de.name, ".") == 0 || strcmp(de.name, "..") == 0)
+                continue;
+            
+            memmove(p, de.name, DIRSIZ);
+            p[DIRSIZ] = 0;
+            
+            find(buf, target_name);
+        }
+    }
+    
+    close(fd);
+}
+
+int
+main(int argc, char *argv[])
+{
+    if(argc != 3){
+        fprintf(2, "Usage: find <path> <filename>\n");
+        fprintf(2, "Example: find . b\n");
+        exit(1);
+    }
+    
+    find(argv[1], argv[2]);
+    exit(0);
+}
\ No newline at end of file
diff --git a/user/pingpong.c b/user/pingpong.c
new file mode 100644
index 0000000..27daa92
--- /dev/null
+++ b/user/pingpong.c
@@ -0,0 +1,53 @@
+#include "kernel/types.h"
+#include "user/user.h"
+
+#define READ 0
+#define WRITE 1
+
+int main(int argc, char *argv[]) {
+    int f2c_pipe[2];  
+    int c2f_pipe[2];  
+    char buffer[1];   
+    int father_pid = getpid(); 
+    int pid;             
+
+    if (pipe(f2c_pipe) < 0 || pipe(c2f_pipe) < 0) {
+        fprintf(2, "pipe creation failed\n");
+        exit(1);
+    }
+
+    pid = fork();
+    if (pid < 0) {
+        fprintf(2, "fork failed\n");
+        exit(1);
+    }
+
+    if (pid == 0) {  // 子进程
+        close(f2c_pipe[WRITE]);  
+        close(c2f_pipe[READ]);   
+
+        read(f2c_pipe[READ], buffer, sizeof(buffer));
+        printf("%d: received ping from pid %d\n", getpid(), father_pid);
+
+        write(c2f_pipe[WRITE], buffer, sizeof(buffer));
+
+        close(f2c_pipe[READ]);
+        close(c2f_pipe[WRITE]);
+        exit(0);
+
+    } else {  // 父进程
+        close(f2c_pipe[READ]);   
+        close(c2f_pipe[WRITE]);  
+
+        buffer[0] = 'X';  
+        write(f2c_pipe[WRITE], buffer, sizeof(buffer));
+        close(f2c_pipe[WRITE]);  
+
+        read(c2f_pipe[READ], buffer, sizeof(buffer));
+        printf("%d: received pong from pid %d\n", getpid(), pid);
+        close(c2f_pipe[READ]);
+        
+        wait(0); 
+        exit(0);
+    }
+}
\ No newline at end of file
diff --git a/user/sleep.c b/user/sleep.c
new file mode 100644
index 0000000..1353a3b
--- /dev/null
+++ b/user/sleep.c
@@ -0,0 +1,15 @@
+#include "kernel/types.h"
+#include "user/user.h" 
+
+int main(int argc, char *argv[]) {
+    if (argc != 2) {
+        
+        printf("Sleep needs one argument!\n");
+        exit(-1);
+    }
+
+    int ticks = atoi(argv[1]); // 将字符串参数转换为整数
+    sleep(ticks); // 调用 sleep 系统调用
+    printf("(nothing happens for a little while)\n");
+    exit(0);
+}
diff --git a/user/testpp.c b/user/testpp.c
new file mode 100644
index 0000000..4fac12a
--- /dev/null
+++ b/user/testpp.c
@@ -0,0 +1 @@
+HEllo
diff --git a/xv6-oslab24-hitsz b/xv6-oslab24-hitsz
new file mode 160000
index 0000000..f107bad
--- /dev/null
+++ b/xv6-oslab24-hitsz
@@ -0,0 +1 @@
+Subproject commit f107bad921cb2528e1dfb8d69653f8d9fe47c42c
