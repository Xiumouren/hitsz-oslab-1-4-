# 简化软件模拟地址翻译实现流程

## 任务目标

将 `copyin()`/`copyinstr()` 中的软件模拟地址翻译改为直接访问，通过在内核页表中添加用户地址空间的映射，利用硬件进行地址翻译，提升性能。

## 实现步骤

### Step 1: 定义 SSTATUS_SUM 标志位

**文件**: `kernel/riscv.h`

**位置**: 在 `SSTATUS_UIE` 定义之后添加

**代码**:
```c
#define SSTATUS_SUM (1L << 18)  // Allow supervisor user memory access
```

**说明**: SSTATUS_SUM 位允许内核访问用户空间的内存。当该位被设置时，内核可以访问标记了 PTE_U 的页表项。

---

### Step 2: 实现 sync_pagetable 函数

**文件**: `kernel/vm.c`

**位置**: 在文件末尾或合适位置添加

**函数声明** (在 `kernel/defs.h` 中添加):
```c
void            sync_pagetable(pagetable_t kpagetable, pagetable_t upagetable);
```

**函数实现**:
```c
// 将用户页表同步到内核页表
// 复制 level-1 页表条目（覆盖用户空间 0x0-0xC0000000）到内核页表
void sync_pagetable(pagetable_t kpagetable, pagetable_t upagetable) {
  if (kpagetable == 0 || upagetable == 0) return;
  
  // 用户空间：0x0 到 0xC0000000 (3GB)
  // 在 Sv39 页表结构中：
  //   level 2 (顶层)：每个条目覆盖 512GB
  //   level 1 (中间层)：每个条目覆盖 1GB  
  //   level 0 (叶子层)：每个条目覆盖 2MB
  // 用户空间 0x0-0xC0000000 全部在 level 2 索引 0 中
  // 我们需要 level 1 的条目 0、1、2（覆盖 3GB）
  
  // 从用户页表获取 level 2 条目（索引 0）
  pte_t *upte_l2 = &upagetable[PX(2, 0)];
  if ((*upte_l2 & PTE_V) == 0) return;
  
  // 从用户页表获取 level 1 页表
  pagetable_t ulevel1 = (pagetable_t)PTE2PA(*upte_l2);
  
  // 从内核页表获取或创建 level 2 条目（索引 0）
  pte_t *kpte_l2 = &kpagetable[PX(2, 0)];
  pagetable_t klevel1;
  
  if ((*kpte_l2 & PTE_V) == 0) {
    // 为内核页表创建 level 1 页表
    klevel1 = (pagetable_t)kalloc();
    if (klevel1 == 0) return;
    memset(klevel1, 0, PGSIZE);
    *kpte_l2 = PA2PTE((uint64)klevel1) | PTE_V;
  } else {
    // 使用已存在的 level 1 页表
    klevel1 = (pagetable_t)PTE2PA(*kpte_l2);
  }
  
  // 复制 level 1 条目 0、1、2（覆盖 0x0-0xC0000000）
  for (int i = 0; i < 3; i++) {
    klevel1[i] = ulevel1[i];
  }
}
```

**说明**: 
- 用户地址空间为 0x0-0xC0000000 (3GB)
- 在 Sv39 页表中，第二级页表的每个条目覆盖 1GB
- 需要复制用户页表第二级页表的索引 0、1、2 到内核页表
- 这种方法共享用户页表的叶子页表，避免复制整个页表

---

### Step 3: 替换 copyin() 和 copyinstr()

**文件**: `kernel/vm.c`

**修改 copyin() 函数**:
```c
int copyin(pagetable_t pagetable, char *dst, uint64 srcva, uint64 len) {
  struct proc *p = myproc();
  
  // Enable supervisor user memory access
  uint64 old_sstatus = r_sstatus();
  w_sstatus(old_sstatus | SSTATUS_SUM);
  
  // Call the new implementation
  int result = copyin_new(pagetable, dst, srcva, len);
  
  // Restore old sstatus
  w_sstatus(old_sstatus);
  
  return result;
}
```

**修改 copyinstr() 函数**:
```c
int copyinstr(pagetable_t pagetable, char *dst, uint64 srcva, uint64 max) {
  struct proc *p = myproc();
  
  // Enable supervisor user memory access
  uint64 old_sstatus = r_sstatus();
  w_sstatus(old_sstatus | SSTATUS_SUM);
  
  // Call the new implementation
  int result = copyinstr_new(pagetable, dst, srcva, max);
  
  // Restore old sstatus
  w_sstatus(old_sstatus);
  
  return result;
}
```

**说明**: 
- 在调用 `copyin_new()`/`copyinstr_new()` 之前设置 SSTATUS_SUM 位
- 调用完成后恢复原来的 sstatus 值
- 这样内核才能访问用户空间的内存

---

### Step 4: 在 fork() 中同步页表

**文件**: `kernel/proc.c`

**位置**: 在 `fork()` 函数中，子进程完成页表复制后

**代码**: 在 `np->sz = p->sz;` 之后添加
```c
  np->sz = p->sz;
  
  // Sync user pagetable to kernel pagetable for child process
  sync_pagetable(np->kernel_pagetable, np->pagetable);
```

**说明**: 
- 子进程继承了父进程的用户页表
- 需要将子进程的用户页表同步到子进程的内核页表中
- `np` 是子进程的 PCB，`p` 是父进程的 PCB

---

### Step 5: 在 exec() 中同步页表

**文件**: `kernel/exec.c`

**位置**: 在 `exec()` 函数中，新页表创建并设置后

**代码**: 在 `p->pagetable = pagetable;` 之后添加
```c
  p->pagetable = pagetable;
  p->sz = sz;
  
  // Sync new user pagetable to kernel pagetable
  sync_pagetable(p->kernel_pagetable, pagetable);
```

**说明**: 
- `exec()` 会创建新的用户页表并替换旧的
- 需要将新的用户页表同步到内核页表中

---

### Step 6: 在 growproc() 中同步页表

**文件**: `kernel/proc.c`

**位置**: 在 `growproc()` 函数中，内存增长或缩减后

**查看 growproc() 函数**:
```c
int growproc(int n) {
  struct proc *p = myproc();
  uint64 sz;
  
  sz = p->sz;
  if (n > 0) {
    if ((sz = uvmalloc(p->pagetable, sz, sz + n)) == 0) {
      return -1;
    }
  } else if (n < 0) {
    sz = uvmdealloc(p->pagetable, sz, sz + n);
  }
  p->sz = sz;
  
  // Sync user pagetable to kernel pagetable after grow/shrink
  sync_pagetable(p->kernel_pagetable, p->pagetable);
  
  return 0;
}
```

**说明**: 
- `growproc()` 会修改用户页表的映射（增加或减少内存）
- 修改后需要同步到内核页表

---

### Step 7: 在 userinit() 中同步页表

**文件**: `kernel/proc.c`

**位置**: 在 `userinit()` 函数中，第一个进程初始化完成后

**查看 userinit() 函数**，在设置完进程状态后添加:
```c
  p->state = RUNNABLE;
  
  // Sync user pagetable to kernel pagetable for init process
  sync_pagetable(p->kernel_pagetable, p->pagetable);
  
  release(&p->lock);
```

**说明**: 
- `userinit()` 创建第一个进程（init）
- 需要将第一个进程的用户页表同步到内核页表

---

### Step 8: 修改内核页表释放函数

**文件**: `kernel/vm.c`

**位置**: 在proc_freekpagetable(pagetable_t kpagetable)函数

void proc_freekpagetable(pagetable_t kpagetable) {
  if (kpagetable == 0) return;
  /*修复翻译时
  scause 0x000000000000000d
  sepc=0x000000008000105e 
  stval=0x0404040404040000
  panic: kerneltrap */

  // 获取内核页表的 Level 2 表项（索引0覆盖了用户空间 0x0-0xC0000000）
  pte_t *pte = &kpagetable[PX(2, 0)];
  if (*pte & PTE_V) {
    // 获取 Level 1 页表页
    pagetable_t level1 = (pagetable_t)PTE2PA(*pte);
    
    // 清除前3个表项（对应 sync_pagetable 复制的内容）
    // 这3个表项指向用户的 L0 页表，它们已经被释放了，不能再访问。
    for (int i = 0; i < 3; i++) {
      level1[i] = 0; 
    }
  }
  freewalk_kernel(kpagetable);
}


---

## 注意事项

1. **页表同步时机**: 必须在用户页表发生变化时同步，包括：
   - 进程创建（fork）
   - 进程执行新程序（exec）
   - 内存分配/回收（growproc/sbrk）
   - 第一个进程初始化（userinit）

2. **SSTATUS_SUM 位**: 
   - 必须在调用 `copyin_new()`/`copyinstr_new()` 之前设置
   - 调用完成后必须清除
   - 这允许内核访问用户空间内存

3. **页表共享**: 
   - 当前实现共享用户页表的第二级页表
   - 在回收页表时需要避免重复回收（freewalk_kernel 已经处理了这个问题）

4. **地址空间范围**: 
   - 用户地址空间: 0x0 - 0xC0000000 (3GB)
   - 每个第二级页表条目覆盖 1GB
   - 需要复制索引 0、1、2 的条目

## 测试

完成所有修改后：

1. **编译**: 
   ```bash
   make clean
   make
   ```

2. **运行测试**:
   ```bash
   make qemu
   # 在 qemu 中运行
   usertests
   ```

3. **评分测试**:
   ```bash
   make grade
   ```

## 常见问题

1. **Q: sync_pagetable 函数中为什么要检查 PTE_V?**
   A: 确保用户页表的条目是有效的，避免访问无效的页表。

2. **Q: 为什么需要设置 SSTATUS_SUM?**
   A: 默认情况下，内核不能访问标记了 PTE_U 的用户页表项。设置 SSTATUS_SUM 后，内核才能访问用户空间。

3. **Q: 页表同步会影响性能吗?**
   A: 页表同步只在页表变化时进行，频率较低。相比软件模拟地址翻译，整体性能会提升。

4. **Q: 如果用户页表被修改但没有同步会怎样?**
   A: 内核页表中的映射会过时，可能导致访问错误的内存或访问失败。